# 05장. 🚪 표현식과 문

## 5.1 값
- `값(value)`이란 **식(표현식 *expression*)이 평가되어 생성된 결과**를 말한다.
- 평가란 식을 해석해서 값을 생성하거나 참조하는 것을 의미한다.

```js
// 10 + 20은 평가되어 숫자 타입의 값 30을 생성한다.
10 + 20; // 30
```

- 모든 값은 데이터 타입을 가지며, 메모리에 2진수(비트의 나열)로 저장된다.
- 메모리에 저장된 값은 데이터 타입에 따라 다르게 해석될 수 있다.
  - ex. 메모리에 저장된 값 `0100 0001`을 숫자 타입으로 해석하면 65지만, `문자열` 타입으로 해석하면 'A'다.
- 변수에 할당되는 것은 값이다.

<br>

## 5.2 리터럴
- `리터럴(literal, 문자 그대로의)` 은 **사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 값을 생성하는 표기법**을 말한다.

```js
// 숫자 리터럴 3
3
```

- 위의 `숫자 리터럴 3`은 사람이 이해할 수 있는 아라비아 숫자를 사용해 숫자 리터럴 3을 코드에 기술하면, JS 엔진이 이를 평가하여 숫자 값 3을 생성한다.
- JS 엔진은 코드가 실행되는 시점인 **런타임**에 리터럴을 평가해 값을 생성한다.
- 리터럴을 사용하여 생성할 수 있는 다양한 값들은 아래와 같다.

리터럴 | 예시 | 비고
:-----:|------|------|
정수 리터럴 | 100 |
부동소수점 리터럴 | 10.5 |
2진수 리터럴 | 0b01000001 | 0b로 시작
8진수 리터럴 | 0o101 | ES6에서 도입. 0o으로 시작
16진수 리터럴 | 0x41 | ES6에서 도입. 0x로 시작
문자열 리터럴 | 'Hello'<br>"world" |
불리언 리터럴 | true<br>false |
null 리터럴 | null |
undefined 리터럴 | undefined |
객체 리터럴 | { name: 'Lee', address: 'Seoul' } |
배열 리터럴 | [ 1, 2, 3 ] |
함수 리터럴 | function() {} |
정규표현식 리터럴 | /[A-Z]+/g |

<br>

## 5.3 표현식
- `표현식(expression)` 은 **값으로 평가될 수 있는 문(statement)** 이다. `표현식 ⊂ 문`
- 즉, **표현식이 평가되면 새로운 값을 생성하거나 기존 값을 참조한다.**
- 5.2의 리터럴은 값으로 평가된다. 따라서 리터럴도 표현식이다.

```js
let score = 100; // 리터럴
// 100은 리터럴이다.
// 리터럴 100은 JS 엔진에 의해 평가되어 값을 생성하므로
// 리터럴은 그 자체로 표현식이다.

let score = 50 + 50; // 리터럴 + 연산자
// 50 + 50은 리터럴과 연산자로 이루어져 있다.
// 하지만 50 + 50도 평가되어 숫자 값 100을 생성하므로 표현식이다.

score // 100, 식별자 참조
// 변수 식별자를 참조하면 변수 값으로 평가된다.
// 식별자 참조는 값을 생성하진 않지만, 값으로 평가되므로 표현식이다.
```

- 이처럼 표현식은 리터럴, 식별자(변수, 함수 등의 이름), 연산자, 함수 호출 등의 조합으로 이뤄질 수 있다. 다음과 같이 다양한 표현식이 있지만 값으로 평가된다는 점에서 모두 동일하다.
- 즉, **값으로 평가될 수 있는 문은 모두 표현식이다.**

```js
// 리터럴 표현식
10
'Hello'

// 식별자 표현식 (선언이 이미 존재한다고 가정)
sum
person.name
arr[1]

// 연산자 표현식
10 + 20
sum = 10
sum != 20

// 함수/메서드 호출 표현식 (선언이 이미 존재한다고 가정)
square()
person.getName()
```

- 표현식은 값으로 평가된다. 이때 표현식과 표현식이 평가된 값은 동등한 관계, 즉 동치(equivalent)다.
- 따라서 표현식은 값처럼 사용할 수 있고, 이것은 문법적으로 값이 위치할 수 있는 자리에는 표현식도 위치할 수 있다는 것을 의미한다.

```js
let x = 1 + 2;

// 식별자 표현식 x는 3으로 평가된다.
x + 3; // 6
```
- 표현식은 다른 표현식의 일부가 되어 새로운 값을 만들어 낼 수 있다.

<br>

## 5.4 문
- `문(statement)`은 **프로그램을 구성하는 기본 단위이자 최소 실행 단위다.**
- `토큰(token)`이란 **문법적인 의미를 가지며, 문법적으로 더 이상 나눌 수 없는 코드의 기본 요소를 의미한다.**

```js
let sum = 1 + 2; // 문

// 토큰 : let, sum, =, 1, +, 2, ;
```
문은 여러 토큰으로 구성되며, 문의 집합으로 이뤄진 것이 바로 프로그램이고, 문을 작성하고 순서에 맞게 나열하는 것이 프로그래밍이다.

문과 표현식을 구별하고 해석할 수 있다면 JS 엔진의 입장에서 코드를 읽을 수 있고 실행 결과를 예측하는 데 도움이 되고, 이는 버그를 줄이고 코드의 품질을 높여준다.

문을 **명령문**이라고도 부른다. 즉, 문은 컴퓨터에 내리는 명령이다.

또한 문은 **선언문, 할당문, 조건문, 반복문** 등으로 구분할 수 있다.

<br>

## 5.5 세미콜론과 세미콜론 자동 삽입 기능
- `세미콜론(;)`은 문의 종료를 나타낸다. 문을 끝낼 때는 세미콜론을 붙여야 한다.
- 단, 0개 이상의 문을 중괄호로 묶은 코드 블록({ ... }) 뒤에는 세미콜론을 붙이지 않는다.
  - ex. `if문`, `for문`, `함수` 등의 코드 블록 뒤에는 세미클론을 붙이지 않는데, 이러한 코드 블록은 언제나 문의 종료를 의미하는 **자체 종결성 self closing**을 갖기 때문이다.
 
<br>

## 5.6 표현식인 문과 표현식이 아닌 문
- 표현식은 문의 일부일 수도 있고, 그 자체로 문이 될 수도 있다.

```js
let x;
// 변수 선언문 : 문O, 표현식X
// -> 값으로 평가될 수 없으므로 표현식이 아니다.

x = 1 + 2;
// x = 1+2 : 문O, 표현식O
// 1, 2, 1+2, x=1+2는 모두 표현식이다.
```

- **표현식인 문과 표현식이 아닌 문을 구별하는 가장 간단한 방법은 변수에 할당해보는 것이다.**
- 표현식인 문은 값으로 평가되므로 변수에 할당할 수 있지만, 표현식이 아닌 문은 값으로 평가할 수 없으므로 변수에 할당하면 에러가 발생한다.

```js
let foo = let x; // SyntaxError: Unexpected token let

let y; // 변수 선언문은 표현식이 아닌 문이다.
y = 100; // 할당문은 표현식인 문이다.

let foo = y = 100; // 표현식인 문은 값처럼 사용할 수 있다.
console.log(foo) // 100
```

#### 💡 완료 값(completion value)
- 크롬 개발자 도구에서 표현식이 아닌 문을 실행하면 언제나 `undefined`를 출력하는데, 이를 완료 값이라 한다.
- 완료 값은 표현식의 평가 결과가 아니다. 따라서 다른 값과 같이 변수에 할당할 수도 없고 참조할 수도 없다.

```js
// 크롬 개발자 도구

// 변수 선언문
var foo = 10; // undefined : 완료 값

// 조건문
if (true) {} // undefined : 완료 값
```